/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package org.useragent.server;

import appsusersevents.client.CloudUsers;
import appsusersevents.client.EventDescription;
import appsusersevents.client.EventUtilities;
import appsusersevents.client.SingleUser;
import com.google.gwt.core.client.GWT;
import com.google.gwt.user.server.rpc.RemoteServiceServlet;

import giga.GigaListener;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import javax.servlet.http.HttpSession;
import org.useragent.client.GWTUserAgentService;
import org.useragent.client.GWTUserAgentServiceAsync;

/**
 *
 * @author giovanna
 */
public class GWTUserAgentServiceImpl extends RemoteServiceServlet implements GWTUserAgentService {

    HashMap<String, GigaListener> sessionListeners = new HashMap();
    private ArrayList<EventDescription> userEventList; //list of recent events generated by
    // explicit actions of this user. The list must be
    // periodically pruned (removing less recent events)
    //NB: userEventList does not include other events relevant for the user
    // --> another list must be defined for that purpose, if the UserAgt
    // needs it for reasoning about the user
    int count; // counter used for disambiguating the userEventList cyclically;
    final int CYCLE = 50; // threashold for eventList maintenance
    ArrayList<String> userSpheres;
    private String userID; // user account DA INIZIALIZZARE QUANDO AUTHENTICATE OK
    CloudUsers cloudUsers = new CloudUsers();

    public void init() {
        userEventList = new ArrayList();
        userSpheres = new ArrayList();
        userSpheres.add("unknown");
        //TEMP qui al posto di questo recuperare i gruppi esistenti da gContacts
        userSpheres.add("itapro");
        userSpheres.add("provaGroup");
//END TEMP

    }

    public String myMethod(String s) {
        // Do something interesting with 's' here on the server.
        return "Server says: " + s;
    }

    // metodi
    // adds an event to the userEventList and cyclically disambiguates the list by context
    private EventDescription addEvent(EventDescription ev) {

        if (ev.getSpheres().size() == 0 && ev.getRelevantSpheres().size() > 1) { //need to disambiguate
            String sph = inferSphereFromTab(ev);
            if (!sph.equalsIgnoreCase("unknown")) { // reduce relevantSpheres field by tab
                ArrayList<String> relevantNew = new ArrayList();
                relevantNew.add(sph);
                ev.setRelevantSpheres(relevantNew);
                ev.setProcessed("byUserAgt");
            }
        }
        userEventList.add(ev);
        if (count >= CYCLE) {
            EventUtilities.disambiguateEventList(userEventList);
            count = 0;
        }
        return ev;
    }

    //scatena possibili inferenze sugli eventi da UM e li ripubblica
    public void addEvents() {
        EventDescription[] events = getListener().getEvents();
        EventDescription[] out = new EventDescription[events.length];
        int k = 0;
        for (int i = 0; i < events.length; i++) {
            EventDescription ev = addEvent(events[i]);
            if ("byUserAgt".equalsIgnoreCase(ev.getProcessed())) {
                out[k++] = ev;
            }
        }
        getListener().putEvents(out);
    }

    //evaluates the user coherence in the usage of tabs by analyzing
    //a list of events. Returns a value in [0..1]
    private double getUserCoherence(Date startDate, Date endDate) {
        ArrayList<EventDescription> eventList = EventUtilities.selectEventsByTime(userEventList, startDate, endDate);
        int userGenEvents = 0;
        int numCoherentEvents = 0;
        double freq = 1; // frequency of user actions performed on the related tab
        for (int i = 0; i < eventList.size(); i++) {
            EventDescription ev = (EventDescription) eventList.get(i);
            if ((userID.equals(ev.getUser()) &&
                    ev.getExplicitEvent().equals("true"))) { // event generated from action on UI
                userGenEvents++;
                ArrayList sphs = ev.getSpheres();
                ArrayList relSphs = ev.getRelevantSpheres();
                if (sphs.contains(ev.getTab()) || // current tab is a sphere of the event
                        relSphs.contains(ev.getTab()) || // current tab is a relevant sphere
                        (sphs.size() == 0 && relSphs.size() == 0)) // completely unclassified event
                {
                    numCoherentEvents++;
                }
            }
        }
        if (userGenEvents > 0) {
            freq = (double) numCoherentEvents / (double) userGenEvents;
        }
        //freq = 0.3; // for testing the estimation of event spheres
        return freq;
    }

    // estimates the reference sphere of an event, given the
    // list of relevant spheres associated to the event and the tab in focus
    // when the event was generated. Currently, it exploits the
    // userEventList list for the evaluation of the user coherence.
    // Maybe, a shorter list could be exploited, if the userEventList
    // list is not regularly cleaned from obsolete events
    // returns "unknown" if it is not able to estimate reference sphere
    private String inferSphereFromTab(EventDescription ev) {
        String tab = ev.getTab();
        String sph = "unknown";
        if (ev.getSpheres().size() != 0) // non ambiguous event
        {
            System.out.println("UserAgt: attempt to estimate sphere from tab on a non ambiguous event! " + ev);
        } else // ambiguous event
        if (ev.getRelevantSpheres().contains(tab) && (getUserCoherence(null, null) >= 0.65)) {
            sph = tab;
        } else // no intersection between tab and relevant spheres
        if (getUserCoherence(null, null) >= 0.85) // very coherent user --> use tab as reference sphere
        {
            sph = tab;
        }
        return sph;
    }

    private void subscribeTo() {
        // invia a Giga il nome dell'evento a cui l'utente si vuole sottoscrivere
        EventDescription template = new EventDescription("*");

        template.setUser(userID);
        template.setExplicitEvent("true");
        template.setProcessed("byContext"); //
        getListener().addEvent(template);
    }

    private GigaListener getListener() {
        String sId = getSession().getId();
        GigaListener ret = sessionListeners.get(sId);
        //       System.out.println("sessionListeners SIZE = " + sessionListeners.size());
        //      System.out.println("sessionListeners: sessionId =  " + sId);
        if (ret == null) {
            ret = new GigaListener(false, false);
            sessionListeners.put(sId, ret);
        }
        //    System.out.println("sessionListeners: ret =  " + ret);
        return ret;
    }

    private HttpSession getSession() {
        // Get the current request and then return its session
        return this.getThreadLocalRequest().getSession();
    }

    public String authenticate(String s) {
        String userEmail = "";
        SingleUser sU = cloudUsers.getUser(s);
        System.out.println("UserAgent AUTHENTICATE " + s);
        if (sU != null) {
            userEmail = sU.getMailAddress();
            userID = userEmail;
            // subscribeTo();   ?? no nso se qui
        } else {
            System.out.println("singleUSer NULL");
        }
        return userEmail;
    }
}
