package myCLasses;

/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.*;

/**
 *
 * @author liliana
 */
public class UserAgt {

    private String userID; // user account
    private ArrayList<EventDescription> userEventList; //list of recent events generated by
    // explicit actions of this user. The list must be
    // periodically pruned (removing less recent events

    private int count; // counter used for disambiguating the userEventList cyclically;
    private final int CYCLE = 10; // threashold for eventList maintenance

    private final int LENGTH = 10; // max length of user history maintained by userAgt
    
    // for each group the user belongs to, this specifies the group members
    private HashMap<String, ArrayList<String>> groupsTable;
    // projection of the global spheresTable on the individual user
    private HashMap<String, ArrayList<String>> spheresTable;
    // activityDegrees for each user sphere
    private ArrayList<ActivityDegree> activityDegrees;
    // spheres of the last user event received by UserAgt
    private ArrayList<String>lastFocus;
    // spheres whose notifications do not have to be filtered
    private ArrayList<String>noFilter;

    public UserAgt(String usr) {
        userID = usr; // da settare con il login utente!!!
        userEventList = new ArrayList();
        groupsTable = new HashMap();
        spheresTable = new HashMap(); 
        ArrayList<String> userSpheres = new ArrayList();
        userSpheres.add("unknown");
        spheresTable.put("userID", userSpheres);
        activityDegrees = new ArrayList();
        noFilter = new ArrayList();
        lastFocus = new ArrayList();
    }

    public String getUserID() {
        return userID;
    }

    public ArrayList<String> getUserSpheres() {
        return spheresTable.get(userID);
    }

    public ArrayList<String> getLastFocus() {
        return lastFocus;
    }

    public void addNoFilter(String sph) {
        noFilter.add(sph);
    }

    public ArrayList<String> getNoFilter() {
        return noFilter;
    }

    // adds a new group to the group table and updates the
    // spheres table accordingly
    public void addGroup(Sphere sph) {
        String gName = sph.getName();
        if (gName != null) {
            EventUtilities.addGroup(gName, sph.getMembers(),
                                    groupsTable, spheresTable);
            activityDegrees.add(new ActivityDegree(gName, 0));
        }
    }

    // removes a group from the group table and updates the
    // userSpheres accordingly
    public void deleteGroup(String gName) {
        if (gName != null) {
            EventUtilities.deleteGroup(gName, groupsTable, spheresTable);
                    // remove activity degree of user
            for (int i=0; i< activityDegrees.size(); i++) {
                ActivityDegree ad = activityDegrees.get(i);
                if (gName.equals(ad.getSphere()))
                    activityDegrees.remove(i);
            }
        }
    }

    public String getGroupsTableAsString() {
        return groupsTable.toString();
    }

    public String getActivityDegrees() {
        String out = "";
        return activityDegrees.toString();
    }

    private void resetActivityDegrees() { // resets the user activity degrees
        for (int i=0; i<activityDegrees.size(); i++) {
            ActivityDegree ad = activityDegrees.get(i);
            ad.setCount(0);
        }
    }

    // adds an event to the userEventList
    // needs to be synchronized because events are generated in parallel
    // --> can generate concurrentModificationException
    // returns true if ev changes the lastFocus, false otherwise
    public synchronized boolean addEvent(EventDescription ev) {
                    // assume that the new event does not change lastFocus (continuity)
        boolean focusChange = false;
        // selective reception of events: only events generated
        // by UI actions of this user, and already processed by the EventAnalyzer
        if (ev.getProcessed().equalsIgnoreCase("byContext") &&
                ev.getUser().equalsIgnoreCase(userID) &&
                ev.getExplicitEvent().equalsIgnoreCase("true")) {
            userEventList.add(ev);
            count++;
            if (count >= CYCLE) {
                EventUtilities.disambiguateEventList(userEventList);
                count = 0;
            }
            // update activity degrees for each sphere of ev
            ArrayList<String> spheres = ev.getSpheres();
            if (spheres.size() > 0) { // event is tagged by sphere
                                      // update last focus of user
                focusChange = checkFocusChange(lastFocus, spheres);
                lastFocus = spheres;
                updateActivityDegrees(spheres);
            } else { // event is not tagged -> use context to disambiguate
                ArrayList<String> relSpheres = ev.getRelevantSpheres();
                            // update (estimated) last focus of user
                focusChange = checkFocusChange(lastFocus, relSpheres);
                lastFocus = relSpheres;
                updateActivityDegrees(relSpheres);
            }
            // prune old events from userEvent list (to forget less recent activity)
            if (userEventList.size()>LENGTH)
                userEventList.remove(0);
        }
        return focusChange;
    }

            // checks if the spheres/relevantSpheres of ev change user last focus
    private boolean checkFocusChange(ArrayList<String>lastF, ArrayList<String>sphs) {
        return EventUtilities.intersects(lastF, sphs);
    }


    // updates user activity degrees on the basis of the spheres of event
    private void updateActivityDegrees(ArrayList<String> spheres) {
        for (int i = 0; i < spheres.size(); i++) {
                    String sph = spheres.get(i);
                    for (int j = 0; j < activityDegrees.size(); j++) {
                        ActivityDegree act = activityDegrees.get(j);
                        if (sph.equals(act.getSphere()))
                            act.incrementCount();
                    }
        }
    }


    public String getuserEventListAsString() {
        String out = "";
        for (int i = 0; i < userEventList.size(); i++) {
            out = out + userEventList.get(i).toString() + "\n";
        }
        return out;
    }

    //
    public ArrayList<String> getCurrentFocus() {
        ArrayList<String> cf = lastFocus;
        if (lastFocus.size()>1) {// the last user action is ambiguous
                                 // intersect event tags with recent history
            ArrayList<String> inters = EventUtilities.getIntersection(lastFocus, getTopSpheres());
            if (inters.size()>0)
                cf = inters;
        }
        return cf;
    }

    public void setLastFocus(ArrayList<String>spheres) {
        lastFocus = spheres;
    }

    // selects the top ranked user spheres, given the userHistory
    protected ArrayList<String> getTopSpheres() {
        ArrayList topSpheres = new ArrayList();
        int max = Integer.MIN_VALUE;
        int min = Integer.MAX_VALUE;
        for (int i=0; i<activityDegrees.size(); i++) {
            ActivityDegree ad = activityDegrees.get(i);
            if (ad.getCount()>max)
                max = ad.getCount();
            if (ad.getCount()<min)
                min = ad.getCount();
        }
        int interval = max - min;
                // select as delta 20% of the interval between min and max
        float delta = (float)interval/20;
        float goodCounts = max-delta;
        for (int i=0; i<activityDegrees.size(); i++) {
            ActivityDegree ad = activityDegrees.get(i);
            if (ad.getCount()>=goodCounts)
                topSpheres.add(ad);
        }
        return topSpheres;
    }


        public void clear() { // cleans the user history
        userEventList = new ArrayList();
        lastFocus = new ArrayList();
        resetActivityDegrees();
        count = 0;
    }

}// end class


