/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

package eventwatcher;

/**
 *
 * @author giovanna
 */
import appsusersevents.client.EventDescription;
import appsusersevents.client.EventUtilities;
import giga.*;
import java.util.ArrayList;
import java.util.HashMap;

public class EventAnalyzer {

    private static GigaListener ret = null;
    private ArrayList<EventDescription> eventHistory;
    int count; // counter used for disambiguating the eventHistory cyclically;
    final int CYCLE = 50; // threashold for eventList maintenance
    // for each defined group, this specifies the group members
    private HashMap<String, ArrayList<String>> groupsTable;
    // for each user, specifies the list of spheres (groups) he belongs to
    // this is computed by analyzing the groupsTable at each modification
    private HashMap<String, ArrayList<String>> userSpheresTable;

    public EventAnalyzer() {
        eventHistory = new ArrayList();
        groupsTable = new HashMap();
        userSpheresTable = new HashMap();
    }

    public ArrayList<EventDescription> getEventHistoryAsString() {
        return eventHistory;
    }

    // adds a new group to the group table and updates the
    // userSpheresTable accordingly
    public void addGroup(String gName, ArrayList<String> members) {
        EventUtilities.addGroup(gName, members, groupsTable, userSpheresTable);
    }

    // removes a group from the group table and updates the
    // userSpheresTable accordingly
    public void deleteGroup(String gName) {
        EventUtilities.deleteGroup(gName, groupsTable, userSpheresTable);
    }

    public String getGroupsTableAsString() {
        return groupsTable.toString();
    }

    public String getUserSpheresTableAsString() {
        return userSpheresTable.toString();
    }

    // analyzes an event and tries to disambiguate the reference spheres, if needed.
    // If the source application handles spheres, the event is not disambiguated
    // because the presence of multiple spheres/destination users is interpreted
    // as wanted by the user.
    // This method returns the hopefully disambiguated event.
    //NBNBNBNBNBNBNBNBNB:
    // this method should also publish the revised event description in GigaSpaces
    // if it modifies the event
    private EventDescription addEvent(EventDescription event) {

        String app = event.getApplication();
        String explicit = event.getExplicitEvent();
        String processed = event.getProcessed();
        String evName = event.getEventName();
        String user = event.getUser();
        ArrayList<String> destinatari = event.getDestinatari();
        ArrayList<String> spheres = event.getSpheres();
        String tab = event.getTab();
        String time = event.getTime();
        ArrayList<String> parameters = event.getParameters();

        EventDescription ev = null;
        if (processed.equalsIgnoreCase("no")) { // new event, to be processed by context
            // and re-published in GigaSpaces
            if (EventUtilities.applicationHandlesSpheres(app)) // app handles spheres -> no disambiguation needed
            {
                ev = new EventDescription(app, explicit, "byContext", evName, user,
                        destinatari, spheres, tab, time, parameters);
            } else // disambiguate by context and set relevantSpheres field
            {
                ev = createDisambiguatedEvent(app, explicit, processed, evName, user, destinatari,
                        spheres, tab, time, parameters);
            }
            if (tab.equals("")) //patches events with unspecified tab
            {
                ev.setTab("unknown");
            }
            eventHistory.add(ev);
            count++;
            if (count >= CYCLE) {
                EventUtilities.disambiguateEventList(eventHistory);
                count = 0;
            }
        } else if (processed.equalsIgnoreCase("byUserAgt")) {
            EventDescription ev1 = new EventDescription(app, explicit, processed, evName, user,
                    destinatari, spheres, tab, time, parameters);
            EventUtilities.modifyEvent(ev1, eventHistory);
        }
        // ignore all the other events (processed "byContext", etc.)
        return ev;
    }

    // Attempt to estimate the relevantSpheres of an ambiugous event by analyzing
    // the spheres of the destination users.
    // This method must be applied to events generated by applications which
    // do not handle spheres
    private EventDescription createDisambiguatedEvent(String app, String explicit,
            String processed, String evName, String userID,
            ArrayList<String> destinatario,
            ArrayList<String> spheres, String tab, String time,
            ArrayList<String> parameters) {
        if (spheres.size() != 0) {
            System.out.println("EventAnalyzer: spheres is not null: the event should not be disambiguated");
        }
        EventDescription ev = new EventDescription(app, explicit, "byContext",
                evName, userID, destinatario,
                spheres, tab, time, parameters);
        // estimates relevant spheres as the intersection of the
        // spheres of all the destination users
        ArrayList<String> relSpheres = userSpheresTable.get(userID);// all user spheres of the user
        if (relSpheres.contains("unknown")) {
            relSpheres.remove("unknown"); // except for "unknown"
        }
        for (int i = 0; i < destinatario.size(); i++) {
            String dest = destinatario.get(i);
            ArrayList<String> uSphs = new ArrayList();
            if (userSpheresTable.containsKey(dest)) {
                uSphs = userSpheresTable.get(dest); // retrieves spheres of dest
            }            // NB: if dest is an unknown user, uSphs is empty --> empty intersection
            relSpheres = EventUtilities.getIntersection(relSpheres, uSphs);
        }
        ev.setRelevantSpheres(relSpheres);
        return ev;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {

        EventAnalyzer evAnalyzer = new EventAnalyzer();

        getListener();

        try {
            for (int i = 0; i < 10000; i++) {
                // riceve eventi ogni 10 secondi sleep(10000)
                Thread.currentThread().sleep(10000);
                EventDescription[] de = ret.getEvents();
                EventDescription[] elab = doStuff(de, evAnalyzer);
                ret.putEvents(elab);
            }
            //  String val = session.readEntry();
            //  System.out.println(" entry letta= " +val);
        } catch (Exception ex) {
            System.out.println("ERROR in main di EventWatcher");
            ex.printStackTrace();
        }
    }

    static EventDescription[] doStuff(EventDescription[] eventsToProcess, EventAnalyzer evAn) {
        EventDescription[] processedEvents = new EventDescription[eventsToProcess.length];
        int k=0;
        for (int i = 0; i < eventsToProcess.length; i++) {
            EventDescription ev = evAn.addEvent(eventsToProcess[i]);
            if ( ev !=null  &&  "byContext".equalsIgnoreCase(ev.getProcessed())) {
                processedEvents[k++] = ev;
            }
        }
        return processedEvents;
    }

    static void getListener() {
        // se il primo par true ricevi tutti gli eventi e non conta il filtro,
        //se false riceve solo quelli del filtro
        ret = new GigaListener(true, true);

        setFilters(ret);
    }

    static private void setFilters(GigaListener listener) {
        EventDescription desc = new EventDescription("*");
        desc.setProcessed("no"); // dobbiamo anche sottoscriverci a userAgent
        listener.addEvent(desc);
        EventDescription desc2 = new EventDescription("*");
        desc2.setProcessed("byUserAgt"); // dobbiamo anche sottoscriverci a userAgent
        listener.addEvent(desc2);
    }
}


